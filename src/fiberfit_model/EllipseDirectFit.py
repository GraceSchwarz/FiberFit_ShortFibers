# Autogenerated with SMOP version
# /Users/ricimorrill/.local/bin/smop EllipseDirectFit.m -o EllipseDirectFit.py

from __future__ import division
# try:
#     from runtime import *
# except ImportError:
#     from smop.runtime import *

from src.fiberfit_model.helpers import debug


def EllipseDirectFit(XY):
    centroid = np.mean(XY, axis=0)
    e1 = (XY[:, 0] - centroid[0]) ** 2
    e2 = (XY[:, 0] - centroid[0]) * ((XY[:, 1] - centroid[1]))
    e3 = (XY[:, 1] - centroid[1]) ** 2
    D1 = np.vstack(([e1, e2, e3])).T
    f1 = XY[:, 0] - centroid[0]
    f2 = XY[:, 1] - centroid[1]
    f3 = np.ones((1, XY.shape[0]))
    D2 = vstack(([f1, f2, f3])).T
    S1 = dot(D1.T, D1)
    S2 = dot(D1.T, D2)
    S3 = dot(D2.T, D2)
    T = dot(-linalg.inv(S3), S2.T)
    M = S1 + (dot(S2, T))
    M = np.vstack(([M[2, :] / 2, - M[1, :], M[0, :] / 2]))
    _eval, evec = linalg.eig(M)
    cond = (4 * evec[0, :] * evec[2, :]) - (evec[1, :] ** 2)
    A1 = evec[:, nonzero(cond > 0)[0]]
    A = np.vstack((A1, dot(T, A1)))
    A3 = A[3] - 2 * A[0] * centroid[0] - A[1] * centroid[1]
    A4 = A[4] - 2 * A[2] * centroid[1] - A[1] * centroid[0]
    A5 = A[5] + A[0] * centroid[0] ** 2 + A[2] * centroid[1] ** 2 + A[1] * centroid[0] * centroid[1] - A[3] * centroid[
        0] - A[4] * centroid[1]
    A[3] = A3
    A[4] = A4
    A[5] = A5
    A = A / linalg.norm(A)
    return A, centroid


import numpy as np
from numpy.linalg import eig, inv
import scipy.ndimage


#
# def fitEllipse(x,y):
#     x = x[:,np.newaxis]
#     y = y[:,np.newaxis]
#     D =  np.hstack((x*x, x*y, y*y, x, y, np.ones_like(x)))
#     S = np.dot(D.T,D)
#     C = np.zeros([6,6])
#     C[0,2] = C[2,0] = 2; C[1,1] = -1
#     E, V =  eig(np.dot(inv(S), C))
#     n = np.argmax(np.abs(E))
#     a = V[:,n]
#     return a
#
#
# def ellipse_center(a):
#     b,c,d,f,g,a = a[1]/2, a[2], a[3]/2, a[4]/2, a[5], a[0]
#     num = b*b-a*c
#     x0=(c*d-b*f)/num
#     y0=(a*f-b*d)/num
#     return np.array([x0,y0])
#
# def ellipse_angle_of_rotation( a ):
#     b,c,d,f,g,a = a[1]/2, a[2], a[3]/2, a[4]/2, a[5], a[0]
#     return 0.5*np.arctan(2*b/(a-c))
#
# def ellipse_axis_length( a ):
#     b,c,d,f,g,a = a[1]/2, a[2], a[3]/2, a[4]/2, a[5], a[0]
#     up = 2*(a*f*f+c*d*d+g*b*b-2*b*d*f-a*c*g)
#     down1=(b*b-a*c)*( (c-a)*np.sqrt(1+4*b*b/((a-c)*(a-c)))-(c+a))
#     down2=(b*b-a*c)*( (a-c)*np.sqrt(1+4*b*b/((a-c)*(a-c)))-(c+a))
#     res1=np.sqrt(up/down1)
#     res2=np.sqrt(up/down2)
#     return np.array([res1, res2])

from pylab import *

# def ellipse2():
#
#     xcenter, ycenter = 0.38, .68
#     #xcenter, ycenter = 0., 0.
#     width, height = 1.0, 3.0
#     angle = -30
#
#     theta = np.arange(0.0, 360.0, 1.0)*np.pi/180.0
#     x = 0.5 * width * np.cos(theta)
#     y = 0.5 * height * np.sin(theta)
#
#     rtheta = angle*np.pi/180.
#     R = np.array([
#         [np.cos(rtheta),  -np.sin(rtheta)],
#         [np.sin(rtheta), np.cos(rtheta)],
#         ])
#
#     x, y = np.dot(R, np.array([x, y]))
#     x += xcenter
#     y += ycenter
#
#     # fig, ax1 = subplots()
#     # ax1.plot(x,y)
#
#     # show(block=True)
#
#     return x,y
#
# def test2():
#
#     x,y = ellipse2()
#
#     c2r = lambda xs: np.array( [ x.real for x in xs ] )
#     a = c2r( fitEllipse(x,y) )
#     center = c2r( ellipse_center(a) )
#     phi = ellipse_angle_of_rotation(a).real
#     axes = c2r( ellipse_axis_length(a) )
#     a, b = axes
#
#     print( "center = ",  center )
#     print( "angle of rotation = ",  phi )
#     print( "axes = ", axes, a, b )
#
#     fig,ax1 = subplots()
#
#     ax1.plot(x,y, label="input")
#
#     # cx = np.arange(center[0], center[0]+a,0.01)
#     cx = np.arange(0,2.0)
#     debug(cx)
#     ax1.plot(cx, poly1d(phi, center[1])(cx), label='a')
#     ax1.plot(cx, poly1d(-center[1], pi-phi)(cx), label='a')
#
#     # line = Line2D([0.0,0.0],[1.0,1.0])
#     # fig.gca().add_line(line)
#     # fig.lines.extend([line])
#
#     fig.text(x=.85,y=.8, s="$\\phi = %.2f$"%(phi))
#
#     ax1.legend()
#
#     show(block=True)
#
# def test():
#     arc = 2.0
#     R = np.arange(0,arc*np.pi, 0.01)
#     x = 1.5*np.cos(R) + 2 + 0.2*np.random.rand(len(R))
#     y = np.sin(R) + 1. + 0.1*np.random.rand(len(R))
#
#     a = fitEllipse(x,y)
#     center = ellipse_center(a)
#     phi = ellipse_angle_of_rotation(a)
#     axes = ellipse_axis_length(a)
#
#     print( "center = ",  center )
#     print( "angle of rotation = ",  phi )
#     print( "axes = ", axes )
#
#
#     a, b = axes
#     xx = center[0] + a*np.cos(R)*np.cos(phi) - b*np.sin(R)*np.sin(phi)
#     yy = center[1] + a*np.cos(R)*np.sin(phi) + b*np.sin(R)*np.cos(phi)
#
#
#     fig = figure()
#
#     plot(x,y)
#     plot(xx,yy, color = 'red')
#     fig.text(x=.85,y=.8, s="$\\phi = %.2f$"%(phi))
#     show(block=True)
#
# if __name__ == '__main__':
#     # test()
#     test2()
